from pathlib import Path
path = Path('routes/admin.js')
text = path.read_text(encoding='utf-8', errors='replace')
marker = 'router.post("/matches/:id/generate-voting-link"'
start = text.find(marker)
if start == -1:
    raise SystemExit('marker not found')
prefix = text[:start]
new_block = r"""// ==============================
// ?? Gerar link de votação pública para a pelada
// ==============================
router.post(\"/matches/:id/generate-voting-link\", requireAdmin, async (req, res) => {\n  try {\n    const matchId = Number(req.params.id);\n    if (Number.isNaN(matchId)) {\n      return res.redirect(\"/admin\");\n    }\n\n    const token = crypto.randomBytes(16).toString(\"hex\");\n\n    await prisma.match.update({\n      where: { id: matchId },\n      data: {\n        votingToken: token,\n        votingStatus: \"OPEN\",\n      },\n    });\n\n    // We don't return the link directly, the view will build it.\n    // We just signal that it was successful.\n    return res.redirect(`/admin/matches/${matchId}?votingLinkGenerated=true`);\n  } catch (err) {\n    console.error(\"Erro ao gerar link de votação:\", err);\n    return res.redirect(`/admin/matches/${req.params.id}?error=votingLink`);\n  }\n});\n\n// ------------------------------\n// Helper: calcula notas e prêmios\n// ------------------------------\nasync function computeMatchRatingsAndAwards(matchId) {\n  const [publicVotes, playerStats] = await Promise.all([\n    prisma.publicVote.findMany({\n      where: { matchId },\n      include: { rankings: true },\n    }),\n    prisma.playerStat.findMany({\n      where: { matchId, present: true },\n      include: { player: true },\n    }),\n  ]);\n\n  if (publicVotes.length === 0) {\n    return { error: \"noVotes\" };\n  }\n\n  // Nota da votação (0-10) usando estrelas e suavização\n  const sumStars = new Map();\n  const votesCount = new Map();\n  let globalStars = 0;\n  let globalVotes = 0;\n\n  const starsFromRank = (rankIndex, totalPlayers) => {\n    if (totalPlayers <= 1) return 5;\n    const t = rankIndex / (totalPlayers - 1);\n    const stars = 5 - 4 * t;\n    return Math.round(stars * 2) / 2;\n  };\n\n  publicVotes.forEach((vote) => {\n    const ordered = [...vote.rankings].sort((a, b) => (a.rank || 0) - (b.rank || 0));\n    const totalPlayers = ordered.length;\n    ordered.forEach((r, idx) => {\n      const stars = starsFromRank(idx, totalPlayers);\n      globalStars += stars;\n      globalVotes += 1;\n      sumStars.set(r.playerId, (sumStars.get(r.playerId) || 0) + stars);\n      votesCount.set(r.playerId, (votesCount.get(r.playerId) || 0) + 1);\n    });\n  });\n\n  const m = globalVotes > 0 ? globalStars / globalVotes : 2.5;\n  const C = 3;\n\n  const finalScores = new Map();\n  playerStats.forEach((stat) => {\n    const vCount = votesCount.get(stat.playerId) || 0;\n    const sum = sumStars.get(stat.playerId) || 0;\n    const R = vCount > 0 ? sum / vCount : m;\n    const voteRating = ((R * vCount + m * C) / (vCount + C)) * 2;\n\n    finalScores.set(stat.playerId, {\n      voteRating,\n      statsRating: 0,\n      finalRating: 0,\n      statId: stat.id,\n      player: stat.player,\n      votesCount: vCount,\n      goals: stat.goals || 0,\n      assists: stat.assists || 0,\n      appearedInPhoto: !!stat.appearedInPhoto,\n    });\n  });\n\n  // Nota de stats (0-10) normalizada por posição\n  const maxGoals = playerStats.reduce((m2, s) => Math.max(m2, s.goals || 0), 0);\n  const maxAssists = playerStats.reduce((m2, s) => Math.max(m2, s.assists || 0), 0);\n\n  playerStats.forEach((stat) => {\n    const score = finalScores.get(stat.playerId);\n    if (!score) return;\n\n    const goals = stat.goals || 0;\n    const assists = stat.assists || 0;\n\n    const goalsRel = maxGoals > 0 ? goals / maxGoals : 0;\n    const assistsRel = maxAssists > 0 ? assists / maxAssists : 0;\n\n    const posNorm = normalizePosition(stat.player.position);\n    let gW = 0.6;\n    let aW = 0.3;\n    let photoBonus = stat.appearedInPhoto ? 0.1 : 0;\n\n    if (posNorm === \"GOL\") {\n      gW = 0.2;\n      aW = 0.3;\n      photoBonus = stat.appearedInPhoto ? 0.5 : 0;\n    } else if (posNorm === \"ZAG\") {\n      gW = 0.3;\n      aW = 0.4;\n      photoBonus = stat.appearedInPhoto ? 0.3 : 0;\n    } else if (posNorm === \"MEI\" || posNorm === \"VOL\") {\n      gW = 0.4;\n      aW = 0.4;\n      photoBonus = stat.appearedInPhoto ? 0.2 : 0;\n    }\n\n    let score0to1 = goalsRel * gW + assistsRel * aW + photoBonus;\n    if (score0to1 > 1) score0to1 = 1;\n    const statsRating = score0to1 * 10;\n\n    score.statsRating = statsRating;\n    score.positionNorm = posNorm;\n  });\n\n  const scoresArr = Array.from(finalScores.values()).map((score) => {\n    const finalRating = Number((0.7 * (score.voteRating || 0) + 0.3 * (score.statsRating || 0)).toFixed(2));\n    score.finalRating = finalRating;\n    return score;\n  });\n\n  const pickBest = (list) => {\n    if (!list || list.length === 0) return null;\n    return [...list].sort((a, b) => {\n      if (b.finalRating !== a.finalRating) return b.finalRating - a.finalRating;\n      const contribA = (a.goals || 0) + (a.assists || 0);\n      const contribB = (b.goals || 0) + (b.assists || 0);\n      if (contribB !== contribA) return contribB - contribA;\n      return (b.votesCount || 0) - (a.votesCount || 0);\n    })[0];\n  };\n\n  const byGroup = {\n    GOL: scoresArr.filter((s) => s.positionNorm === \"GOL\"),\n    ZAG: scoresArr.filter((s) => s.positionNorm === \"ZAG\"),\n    MEI: scoresArr.filter((s) => s.positionNorm === \"MEI\" || s.positionNorm === \"VOL\"),\n    ATA: scoresArr.filter((s) => s.positionNorm === \"ATA\"),\n  };\n\n  const awards = {\n    craque: pickBest(scoresArr),\n    melhor_goleiro: pickBest(byGroup.GOL),\n    melhor_zagueiro: pickBest(byGroup.ZAG),\n    melhor_meia: pickBest(byGroup.MEI),\n    melhor_atacante: pickBest(byGroup.ATA),\n  };\n\n  return { publicVotes, playerStats, finalScores, awards };
}

// ==============================
// ?? Calcular resultados da votação pública (nova matemática)
// ==============================
router.post(\"/matches/:id/calculate-results\", requireAdmin, async (req, res) => {\n  const matchId = Number(req.params.id);\n  if (Number.isNaN(matchId)) {\n    return res.redirect(\"/admin\");\n  }\n\n  try {\n    const result = await computeMatchRatingsAndAwards(matchId);\n    if (result.error === \"noVotes\") {\n      return res.redirect(`/admin/matches/${matchId}?error=noVotes`);\n    }\n\n    const { finalScores, awards } = result;\n\n    const updates = [];\n    finalScores.forEach((score) => {\n      const voteRating = score.voteRating || 0;\n      const statsRating = score.statsRating || 0;\n      const finalRating = Number((0.7 * voteRating + 0.3 * statsRating).toFixed(2));\n      score.finalRating = finalRating;\n\n      updates.push(\n        prisma.playerStat.update({\n          where: { id: score.statId },\n          data: { rating: finalRating },\n        })\n      );\n    });\n\n    await prisma.$transaction(updates);\n\n    await prisma.match.update({\n      where: { id: matchId },\n      data: {\n        votingStatus: \"CLOSED\",\n        awardsJson: awards,\n      },\n    });\n\n    res.redirect(`/admin/matches/${matchId}?resultsCalculated=true`);\n  } catch (err) {\n    console.error(\"Erro ao calcular resultados da votação:\", err);\n    res.redirect(`/admin/matches/${matchId}?error=results`);\n  }\n});\n\n// ==============================
// ??? Card de prêmios (download imagem)
// ==============================
router.get(\"/matches/:id/awards-card\", requireAdmin, async (req, res) => {\n  const matchId = Number(req.params.id);\n  if (Number.isNaN(matchId)) {\n    return res.redirect(\"/admin\");\n  }\n\n  try {\n    const match = await prisma.match.findUnique({ where: { id: matchId } });\n    if (!match) return res.redirect(\"/admin\");\n\n    const result = await computeMatchRatingsAndAwards(matchId);\n    if (result.error === \"noVotes\") {\n      return res.redirect(`/admin/matches/${matchId}?error=noVotes`);\n    }\n\n    const scores = Array.from(result.finalScores.values());\n\n    return res.render(\"awards_card\", {\n      match,\n      awards: result.awards,\n      scores,\n    });\n  } catch (err) {\n    console.error(\"Erro ao carregar card de prêmios:\", err);\n    return res.redirect(`/admin/matches/${matchId}?error=awards`);\n  }\n});\n\nmodule.exports = router;\n"""
path.write_text(prefix + new_block, encoding='utf-8')
